// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BillingCycle string

const (
	BillingCycleMonthly   BillingCycle = "monthly"
	BillingCycleQuarterly BillingCycle = "quarterly"
	BillingCycleAnnually  BillingCycle = "annually"
)

func (e *BillingCycle) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingCycle(s)
	case string:
		*e = BillingCycle(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingCycle: %T", src)
	}
	return nil
}

type NullBillingCycle struct {
	BillingCycle BillingCycle `json:"billing_cycle"`
	Valid        bool         `json:"valid"` // Valid is true if BillingCycle is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingCycle) Scan(value interface{}) error {
	if value == nil {
		ns.BillingCycle, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingCycle.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingCycle) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingCycle), nil
}

type DisputeStatus string

const (
	DisputeStatusNeedsResponse DisputeStatus = "needs_response"
	DisputeStatusUnderReview   DisputeStatus = "under_review"
	DisputeStatusWon           DisputeStatus = "won"
	DisputeStatusLost          DisputeStatus = "lost"
)

func (e *DisputeStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DisputeStatus(s)
	case string:
		*e = DisputeStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for DisputeStatus: %T", src)
	}
	return nil
}

type NullDisputeStatus struct {
	DisputeStatus DisputeStatus `json:"dispute_status"`
	Valid         bool          `json:"valid"` // Valid is true if DisputeStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDisputeStatus) Scan(value interface{}) error {
	if value == nil {
		ns.DisputeStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DisputeStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDisputeStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DisputeStatus), nil
}

type InvoiceStatus string

const (
	InvoiceStatusDraft    InvoiceStatus = "draft"
	InvoiceStatusPending  InvoiceStatus = "pending"
	InvoiceStatusPaid     InvoiceStatus = "paid"
	InvoiceStatusVoid     InvoiceStatus = "void"
	InvoiceStatusRefunded InvoiceStatus = "refunded"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

type JobStatus string

const (
	JobStatusPending   JobStatus = "pending"
	JobStatusRunning   JobStatus = "running"
	JobStatusCompleted JobStatus = "completed"
	JobStatusFailed    JobStatus = "failed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

type OrderStatus string

const (
	OrderStatusDraft          OrderStatus = "draft"
	OrderStatusPendingPayment OrderStatus = "pending_payment"
	OrderStatusPaid           OrderStatus = "paid"
	OrderStatusProvisioning   OrderStatus = "provisioning"
	OrderStatusActive         OrderStatus = "active"
	OrderStatusCancelled      OrderStatus = "cancelled"
	OrderStatusRefunded       OrderStatus = "refunded"
)

func (e *OrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderStatus(s)
	case string:
		*e = OrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderStatus: %T", src)
	}
	return nil
}

type NullOrderStatus struct {
	OrderStatus OrderStatus `json:"order_status"`
	Valid       bool        `json:"valid"` // Valid is true if OrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderStatus), nil
}

type PaymentStatus string

const (
	PaymentStatusPending    PaymentStatus = "pending"
	PaymentStatusProcessing PaymentStatus = "processing"
	PaymentStatusSucceeded  PaymentStatus = "succeeded"
	PaymentStatusFailed     PaymentStatus = "failed"
	PaymentStatusRefunded   PaymentStatus = "refunded"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

type ProductCategory string

const (
	ProductCategoryVps       ProductCategory = "vps"
	ProductCategoryDedicated ProductCategory = "dedicated"
	ProductCategoryOther     ProductCategory = "other"
)

func (e *ProductCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductCategory(s)
	case string:
		*e = ProductCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductCategory: %T", src)
	}
	return nil
}

type NullProductCategory struct {
	ProductCategory ProductCategory `json:"product_category"`
	Valid           bool            `json:"valid"` // Valid is true if ProductCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductCategory) Scan(value interface{}) error {
	if value == nil {
		ns.ProductCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductCategory), nil
}

type RefundStatus string

const (
	RefundStatusPending   RefundStatus = "pending"
	RefundStatusSucceeded RefundStatus = "succeeded"
	RefundStatusFailed    RefundStatus = "failed"
)

func (e *RefundStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RefundStatus(s)
	case string:
		*e = RefundStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RefundStatus: %T", src)
	}
	return nil
}

type NullRefundStatus struct {
	RefundStatus RefundStatus `json:"refund_status"`
	Valid        bool         `json:"valid"` // Valid is true if RefundStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRefundStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RefundStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RefundStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRefundStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RefundStatus), nil
}

type ServiceStatus string

const (
	ServiceStatusPending      ServiceStatus = "pending"
	ServiceStatusProvisioning ServiceStatus = "provisioning"
	ServiceStatusActive       ServiceStatus = "active"
	ServiceStatusSuspended    ServiceStatus = "suspended"
	ServiceStatusCancelled    ServiceStatus = "cancelled"
	ServiceStatusTerminated   ServiceStatus = "terminated"
)

func (e *ServiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ServiceStatus(s)
	case string:
		*e = ServiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ServiceStatus: %T", src)
	}
	return nil
}

type NullServiceStatus struct {
	ServiceStatus ServiceStatus `json:"service_status"`
	Valid         bool          `json:"valid"` // Valid is true if ServiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullServiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ServiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ServiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullServiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ServiceStatus), nil
}

type UserRole string

const (
	UserRoleCustomer UserRole = "customer"
	UserRoleAdmin    UserRole = "admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type AuditLog struct {
	ID         uuid.UUID       `json:"id"`
	UserID     pgtype.UUID     `json:"user_id"`
	Action     string          `json:"action"`
	EntityType string          `json:"entity_type"`
	EntityID   pgtype.UUID     `json:"entity_id"`
	OldValues  json.RawMessage `json:"old_values"`
	NewValues  json.RawMessage `json:"new_values"`
	IpAddress  pgtype.Text     `json:"ip_address"`
	UserAgent  pgtype.Text     `json:"user_agent"`
	CreatedAt  time.Time       `json:"created_at"`
}

type CustomerProfile struct {
	ID           uuid.UUID   `json:"id"`
	UserID       uuid.UUID   `json:"user_id"`
	CompanyName  pgtype.Text `json:"company_name"`
	FullName     pgtype.Text `json:"full_name"`
	Phone        pgtype.Text `json:"phone"`
	AddressLine1 pgtype.Text `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
	City         pgtype.Text `json:"city"`
	State        pgtype.Text `json:"state"`
	PostalCode   pgtype.Text `json:"postal_code"`
	Country      pgtype.Text `json:"country"`
	TaxID        pgtype.Text `json:"tax_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

type Dispute struct {
	ID              uuid.UUID          `json:"id"`
	PaymentID       uuid.UUID          `json:"payment_id"`
	StripeDisputeID pgtype.Text        `json:"stripe_dispute_id"`
	Amount          pgtype.Numeric     `json:"amount"`
	Reason          pgtype.Text        `json:"reason"`
	Status          DisputeStatus      `json:"status"`
	EvidenceDueBy   pgtype.Timestamptz `json:"evidence_due_by"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

type Invoice struct {
	ID            uuid.UUID          `json:"id"`
	UserID        uuid.UUID          `json:"user_id"`
	OrderID       pgtype.UUID        `json:"order_id"`
	InvoiceNumber string             `json:"invoice_number"`
	Status        InvoiceStatus      `json:"status"`
	Subtotal      pgtype.Numeric     `json:"subtotal"`
	Tax           pgtype.Numeric     `json:"tax"`
	Total         pgtype.Numeric     `json:"total"`
	Currency      string             `json:"currency"`
	DueDate       pgtype.Timestamptz `json:"due_date"`
	PaidAt        pgtype.Timestamptz `json:"paid_at"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
}

type InvoiceItem struct {
	ID          uuid.UUID      `json:"id"`
	InvoiceID   uuid.UUID      `json:"invoice_id"`
	Description string         `json:"description"`
	Quantity    int32          `json:"quantity"`
	UnitPrice   pgtype.Numeric `json:"unit_price"`
	Amount      pgtype.Numeric `json:"amount"`
	CreatedAt   time.Time      `json:"created_at"`
}

type Order struct {
	ID          uuid.UUID      `json:"id"`
	UserID      uuid.UUID      `json:"user_id"`
	Status      OrderStatus    `json:"status"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
	Currency    string         `json:"currency"`
	Notes       pgtype.Text    `json:"notes"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

type OrderItem struct {
	ID           uuid.UUID      `json:"id"`
	OrderID      uuid.UUID      `json:"order_id"`
	PlanID       uuid.UUID      `json:"plan_id"`
	PlanSnapshot []byte         `json:"plan_snapshot"`
	Quantity     int32          `json:"quantity"`
	UnitPrice    pgtype.Numeric `json:"unit_price"`
	BillingCycle BillingCycle   `json:"billing_cycle"`
	CreatedAt    time.Time      `json:"created_at"`
}

type Payment struct {
	ID                      uuid.UUID      `json:"id"`
	UserID                  uuid.UUID      `json:"user_id"`
	InvoiceID               pgtype.UUID    `json:"invoice_id"`
	StripePaymentIntentID   pgtype.Text    `json:"stripe_payment_intent_id"`
	StripeCheckoutSessionID pgtype.Text    `json:"stripe_checkout_session_id"`
	Amount                  pgtype.Numeric `json:"amount"`
	Currency                string         `json:"currency"`
	Status                  PaymentStatus  `json:"status"`
	Method                  pgtype.Text    `json:"method"`
	CreatedAt               time.Time      `json:"created_at"`
	UpdatedAt               time.Time      `json:"updated_at"`
}

type PaymentEvent struct {
	ID            uuid.UUID          `json:"id"`
	StripeEventID string             `json:"stripe_event_id"`
	EventType     string             `json:"event_type"`
	Payload       []byte             `json:"payload"`
	Processed     bool               `json:"processed"`
	ErrorMessage  pgtype.Text        `json:"error_message"`
	CreatedAt     time.Time          `json:"created_at"`
	ProcessedAt   pgtype.Timestamptz `json:"processed_at"`
}

type Plan struct {
	ID             uuid.UUID       `json:"id"`
	ProductID      uuid.UUID       `json:"product_id"`
	Name           string          `json:"name"`
	Slug           string          `json:"slug"`
	Description    pgtype.Text     `json:"description"`
	CpuCores       pgtype.Int4     `json:"cpu_cores"`
	MemoryMb       pgtype.Int4     `json:"memory_mb"`
	DiskGb         pgtype.Int4     `json:"disk_gb"`
	BandwidthTb    pgtype.Numeric  `json:"bandwidth_tb"`
	PriceMonthly   pgtype.Numeric  `json:"price_monthly"`
	PriceQuarterly pgtype.Numeric  `json:"price_quarterly"`
	PriceAnnually  pgtype.Numeric  `json:"price_annually"`
	SetupFee       pgtype.Numeric  `json:"setup_fee"`
	IsActive       bool            `json:"is_active"`
	SortOrder      int32           `json:"sort_order"`
	Features       json.RawMessage `json:"features"`
	CreatedAt      time.Time       `json:"created_at"`
	UpdatedAt      time.Time       `json:"updated_at"`
}

type Product struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Slug        string          `json:"slug"`
	Description pgtype.Text     `json:"description"`
	Category    ProductCategory `json:"category"`
	IsActive    bool            `json:"is_active"`
	SortOrder   int32           `json:"sort_order"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

type ProvisioningJob struct {
	ID          uuid.UUID          `json:"id"`
	ServiceID   uuid.UUID          `json:"service_id"`
	JobType     string             `json:"job_type"`
	Status      JobStatus          `json:"status"`
	Attempts    int32              `json:"attempts"`
	MaxAttempts int32              `json:"max_attempts"`
	LastError   pgtype.Text        `json:"last_error"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

type Refund struct {
	ID             uuid.UUID      `json:"id"`
	PaymentID      uuid.UUID      `json:"payment_id"`
	StripeRefundID pgtype.Text    `json:"stripe_refund_id"`
	Amount         pgtype.Numeric `json:"amount"`
	Reason         pgtype.Text    `json:"reason"`
	Status         RefundStatus   `json:"status"`
	CreatedBy      pgtype.UUID    `json:"created_by"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

type Service struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	OrderItemID uuid.UUID          `json:"order_item_id"`
	PlanID      uuid.UUID          `json:"plan_id"`
	Status      ServiceStatus      `json:"status"`
	Hostname    pgtype.Text        `json:"hostname"`
	IpAddress   pgtype.Text        `json:"ip_address"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CancelledAt pgtype.Timestamptz `json:"cancelled_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

type User struct {
	ID            uuid.UUID `json:"id"`
	Email         string    `json:"email"`
	PasswordHash  string    `json:"password_hash"`
	Name          string    `json:"name"`
	Role          UserRole  `json:"role"`
	EmailVerified bool      `json:"email_verified"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}
