// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: provisioning_jobs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeJob = `-- name: CompleteJob :one
UPDATE provisioning_jobs SET status = 'completed', completed_at = NOW(), updated_at = NOW()
WHERE id = $1 RETURNING id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at
`

func (q *Queries) CompleteJob(ctx context.Context, id uuid.UUID) (ProvisioningJob, error) {
	row := q.db.QueryRow(ctx, completeJob, id)
	var i ProvisioningJob
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.JobType,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProvisioningJob = `-- name: CreateProvisioningJob :one
INSERT INTO provisioning_jobs (service_id, job_type, status)
VALUES ($1, $2, 'pending')
RETURNING id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at
`

type CreateProvisioningJobParams struct {
	ServiceID uuid.UUID `json:"service_id"`
	JobType   string    `json:"job_type"`
}

func (q *Queries) CreateProvisioningJob(ctx context.Context, arg CreateProvisioningJobParams) (ProvisioningJob, error) {
	row := q.db.QueryRow(ctx, createProvisioningJob, arg.ServiceID, arg.JobType)
	var i ProvisioningJob
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.JobType,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const failJob = `-- name: FailJob :one
UPDATE provisioning_jobs SET status = 'failed', last_error = $2, updated_at = NOW()
WHERE id = $1 RETURNING id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at
`

type FailJobParams struct {
	ID        uuid.UUID   `json:"id"`
	LastError pgtype.Text `json:"last_error"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) (ProvisioningJob, error) {
	row := q.db.QueryRow(ctx, failJob, arg.ID, arg.LastError)
	var i ProvisioningJob
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.JobType,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProvisioningJobByID = `-- name: GetProvisioningJobByID :one
SELECT id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at FROM provisioning_jobs WHERE id = $1
`

func (q *Queries) GetProvisioningJobByID(ctx context.Context, id uuid.UUID) (ProvisioningJob, error) {
	row := q.db.QueryRow(ctx, getProvisioningJobByID, id)
	var i ProvisioningJob
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.JobType,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobsByService = `-- name: ListJobsByService :many
SELECT id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at FROM provisioning_jobs WHERE service_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListJobsByService(ctx context.Context, serviceID uuid.UUID) ([]ProvisioningJob, error) {
	rows, err := q.db.Query(ctx, listJobsByService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProvisioningJob{}
	for rows.Next() {
		var i ProvisioningJob
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.JobType,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingJobs = `-- name: ListPendingJobs :many
SELECT id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at FROM provisioning_jobs WHERE status = 'pending' ORDER BY created_at ASC LIMIT $1
`

func (q *Queries) ListPendingJobs(ctx context.Context, limit int32) ([]ProvisioningJob, error) {
	rows, err := q.db.Query(ctx, listPendingJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProvisioningJob{}
	for rows.Next() {
		var i ProvisioningJob
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.JobType,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRetryableJobs = `-- name: ListRetryableJobs :many
SELECT id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at FROM provisioning_jobs
WHERE status = 'failed' AND attempts < max_attempts
ORDER BY created_at ASC LIMIT $1
`

func (q *Queries) ListRetryableJobs(ctx context.Context, limit int32) ([]ProvisioningJob, error) {
	rows, err := q.db.Query(ctx, listRetryableJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProvisioningJob{}
	for rows.Next() {
		var i ProvisioningJob
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.JobType,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startJob = `-- name: StartJob :one
UPDATE provisioning_jobs SET status = 'running', started_at = NOW(), attempts = attempts + 1, updated_at = NOW()
WHERE id = $1 RETURNING id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at
`

func (q *Queries) StartJob(ctx context.Context, id uuid.UUID) (ProvisioningJob, error) {
	row := q.db.QueryRow(ctx, startJob, id)
	var i ProvisioningJob
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.JobType,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE provisioning_jobs SET status = $2, updated_at = NOW() WHERE id = $1 RETURNING id, service_id, job_type, status, attempts, max_attempts, last_error, started_at, completed_at, created_at, updated_at
`

type UpdateJobStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status JobStatus `json:"status"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (ProvisioningJob, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.ID, arg.Status)
	var i ProvisioningJob
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.JobType,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
